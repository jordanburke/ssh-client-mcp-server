#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js"
import { ErrorCode, McpError } from "@modelcontextprotocol/sdk/types.js"
import { Client as SSHClient } from "ssh2"
import { z } from "zod"
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js"

// Example usage: node build/index.js --host=1.2.3.4 --port=22 --user=root --password=pass --key=path/to/key
function parseArgv() {
  const args = process.argv.slice(2)
  const config: Record<string, string> = {}
  for (const arg of args) {
    const match = arg.match(/^--([^=]+)=(.*)$/)
    if (match) {
      config[match[1]] = match[2]
    }
  }
  return config
}

const argvConfig = parseArgv()

const HOST = argvConfig.host
const PORT = argvConfig.port ? parseInt(argvConfig.port) : 22
const USER = argvConfig.user
const PASSWORD = argvConfig.password
const KEY = argvConfig.key

function validateConfig(config: Record<string, string>) {
  const errors = []
  if (!config.host) errors.push("Missing required --host")
  if (!config.user) errors.push("Missing required --user")
  if (config.port && isNaN(Number(config.port))) errors.push("Invalid --port")
  if (errors.length > 0) {
    throw new Error("Configuration error:\n" + errors.join("\n"))
  }
}

validateConfig(argvConfig)

const server = new McpServer({
  name: "SSH MCP Server",
  version: "1.0.5",
  capabilities: {
    resources: {},
    tools: {},
  },
})

server.tool(
  "exec",
  "Execute a shell command on the remote SSH server and return the output.",
  {
    command: z.string().describe("Shell command to execute on the remote SSH server"),
  },
  async ({ command }) => {
    // Sanitize command input
    if (typeof command !== "string" || !command.trim()) {
      throw new McpError(ErrorCode.InternalError, "Command must be a non-empty string.")
    }
    const sshConfig: any = {
      host: HOST,
      port: PORT,
      username: USER,
    }
    try {
      if (PASSWORD) {
        sshConfig.password = PASSWORD
      } else if (KEY) {
        const fs = await import("fs/promises")
        sshConfig.privateKey = await fs.readFile(KEY, "utf8")
      }
      const result = await execSshCommand(sshConfig, command)
      return result
    } catch (err: any) {
      // Wrap unexpected errors
      if (err instanceof McpError) throw err
      throw new McpError(ErrorCode.InternalError, `Unexpected error: ${err?.message || err}`)
    }
  },
)

async function execSshCommand(
  sshConfig: any,
  command: string,
): Promise<{
  [x: string]: unknown
  content: (
    | { [x: string]: unknown; type: "text"; text: string }
    | {
        [x: string]: unknown
        type: "image"
        data: string
        mimeType: string
      }
    | { [x: string]: unknown; type: "audio"; data: string; mimeType: string }
    | {
        [x: string]: unknown
        type: "resource"
        resource: any
      }
  )[]
}> {
  return new Promise((resolve, reject) => {
    const conn = new SSHClient()
    conn.on("ready", () => {
      conn.exec(command, (err, stream) => {
        if (err) {
          reject(new McpError(ErrorCode.InternalError, `SSH exec error: ${err.message}`))
          conn.end()
          return
        }
        let stdout = ""
        let stderr = ""
        stream.on("close", (code: number, _signal: string) => {
          conn.end()
          if (stderr) {
            reject(new McpError(ErrorCode.InternalError, `Error (code ${code}):\n${stderr}`))
          } else {
            resolve({
              content: [
                {
                  type: "text",
                  text: stdout,
                },
              ],
            })
          }
        })
        stream.on("data", (data: Buffer) => {
          stdout += data.toString()
        })
        stream.stderr.on("data", (data: Buffer) => {
          stderr += data.toString()
        })
      })
    })
    conn.on("error", (err) => {
      reject(new McpError(ErrorCode.InternalError, `SSH connection error: ${err.message}`))
    })
    conn.connect(sshConfig)
  })
}

async function main() {
  const transport = new StdioServerTransport()
  await server.connect(transport)
  console.error("SSH MCP Server running on stdio")
}

main().catch((error) => {
  console.error("Fatal error in main():", error)
  process.exit(1)
})
